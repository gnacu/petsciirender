<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>
            C64 PETSCII Art Generator v4
        </title>
        <style type='text/css'>
        
        </style>
    </head>
    <body onload='Init();'>
		<script type='text/javascript'>
            // v1: Originally written by Gregory Nacu.
            //     Add black/white support, dithering, and color matching algorithm.
            //     Visit http://c64os.com and https://c64os.com/post/petsciiartrenderer
            //     for more information.
            //
            // v2: Enhancement by Warren Wilbur.
            //     Add grayscale working image support (when dithering is disabled) and
            //     render using addition of absolute color differences (better results
            //     for photographic source images).
            //
            // v3: Enhancement by Warren Wilbur.
            //     Add grayscale (multiple color support) and render character sets
            //     (in each selected color) to support grayscale PETSCII output.
            //     Cleanup interface to support incremental processing (top-to-bottom).
            //     Add contrast and brightness adjustment.
            //
            // v4: Enhancement by Warren Wilbur.
            //     Add support for all sixteen C64 colors. Add support for changing
            //     background color.
            var CHARSET    = "upperlower"
            var CHARACTERS = 256;
            var WIDTH      = 320;
            var HEIGHT        = 200;
            var CWIDTH     = 8;
            var CHEIGHT    = 8;

            var C64_COLOR_CODE_BLACK =       0;
            var C64_COLOR_CODE_WHITE =       1;
            var C64_COLOR_CODE_RED =         2;
            var C64_COLOR_CODE_CYAN =        3;
            var C64_COLOR_CODE_PURPLE =      4;
            var C64_COLOR_CODE_GREEN =       5;
            var C64_COLOR_CODE_BLUE =        6;
            var C64_COLOR_CODE_YELLOW =      7;
            var C64_COLOR_CODE_ORANGE =      8;
            var C64_COLOR_CODE_BROWN =       9;
            var C64_COLOR_CODE_LIGHTRED =   10;
            var C64_COLOR_CODE_DARKGREY =   11;
            var C64_COLOR_CODE_GREY =       12;
            var C64_COLOR_CODE_LIGHTGREEN = 13;
            var C64_COLOR_CODE_LIGHTBLUE =  14;
            var C64_COLOR_CODE_LIGHTGREY =  15;

            // refer to https://www.c64-wiki.com/wiki/Color
            var C64_RGB_COLOR_BLACK =      [  0,  0,  0];
            var C64_RGB_COLOR_WHITE =      [255,255,255];
            var C64_RGB_COLOR_RED =        [136,  0,  0];
            var C64_RGB_COLOR_CYAN =       [170,255,238];
            var C64_RGB_COLOR_PURPLE =     [204, 68,204];
            var C64_RGB_COLOR_GREEN =      [  0,204, 85];
            var C64_RGB_COLOR_BLUE =       [  0,  0,170];
            var C64_RGB_COLOR_YELLOW =     [238,238,119];
            var C64_RGB_COLOR_ORANGE =     [221,136, 85];
            var C64_RGB_COLOR_BROWN =      [102, 68,  0];
            var C64_RGB_COLOR_LIGHTRED =   [255,119,119];
            var C64_RGB_COLOR_DARKGREY =   [ 51, 51, 51];
            var C64_RGB_COLOR_GREY =       [119,119,119];
            var C64_RGB_COLOR_LIGHTGREEN = [170,255,102];
            var C64_RGB_COLOR_LIGHTBLUE =  [  0,136,255];
            var C64_RGB_COLOR_LIGHTGREY =  [187,187,187];

            var C64_SELECTED_RGB_COLORS = [];
 
            var contrast = 0;
            var brightness = 0;
            
            // compares each color component of RGB color and returns TRUE on match, FALSE otherwise.
            function MatchRgbColors(rgbColor1, rgbColor2) {
                match = false;
                if ( (rgbColor1[0] == rgbColor2[0]) &&
                     (rgbColor1[1] == rgbColor2[1]) &&
                     (rgbColor1[2] == rgbColor2[2]) ) {
                    match = true;
                }
                return match;
            }

            // find specified RGB color in C64_SELECTED_RGB_COLORS array and return it's index, return undefined if not found.
            function FindIndexOfSelectedColor(rgbColor) {
                var colorIndex = -1;
                for (var i=0; i<C64_SELECTED_RGB_COLORS.length; i++) {
                    if (MatchRgbColors(C64_SELECTED_RGB_COLORS[i], rgbColor)) {
                        colorIndex = i;
                        break;
                    }
                }
                return colorIndex;
            }

            // Find matching C64 RGB color and return VIC-II (C64) color code, undefined if no match
            function GetC64ColorCode(rgbColor) {
                var colorCode = undefined;
                if (MatchRgbColors(rgbColor, C64_RGB_COLOR_BLACK)) {
                    colorCode = C64_COLOR_CODE_BLACK;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_WHITE)) {
                    colorCode = C64_COLOR_CODE_WHITE;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_RED)) {
                    colorCode = C64_COLOR_CODE_RED;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_CYAN)) {
                    colorCode = C64_COLOR_CODE_CYAN;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_PURPLE)) {
                    colorCode = C64_COLOR_CODE_PURPLE;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_GREEN)) {
                    colorCode = C64_COLOR_CODE_GREEN;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_BLUE)) {
                    colorCode = C64_COLOR_CODE_BLUE;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_YELLOW)) {
                    colorCode = C64_COLOR_CODE_YELLOW;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_ORANGE)) {
                    colorCode = C64_COLOR_CODE_ORANGE;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_BROWN)) {
                    colorCode = C64_COLOR_CODE_BROWN;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_LIGHTRED)) {
                    colorCode = C64_COLOR_CODE_LIGHTRED;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_DARKGREY)) {
                    colorCode = C64_COLOR_CODE_DARKGREY;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_GREY)) {
                    colorCode = C64_COLOR_CODE_GREY;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_LIGHTGREEN)) {
                    colorCode = C64_COLOR_CODE_LIGHTGREEN;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_LIGHTBLUE)) {
                    colorCode = C64_COLOR_CODE_LIGHTBLUE;
                } else if (MatchRgbColors(rgbColor, C64_RGB_COLOR_LIGHTGREY)) {
                    colorCode = C64_COLOR_CODE_LIGHTGREY;
                }
                return colorCode;
            }

            // Find matching C64 color code and return matching RGB color ([r, g, b]), undefined if no match
            function GetRgbColor(c64ColorCode) {
                console.log(c64ColorCode);
                var rgbColor = undefined;
                switch (c64ColorCode) {
                    case C64_COLOR_CODE_BLACK:
                        rgbColor = C64_RGB_COLOR_BLACK;
                        break;
                    case C64_COLOR_CODE_WHITE:
                        rgbColor = C64_RGB_COLOR_WHITE;
                        break;
                    case C64_COLOR_CODE_RED:
                        rgbColor = C64_RGB_COLOR_RED;
                        break;
                    case C64_COLOR_CODE_CYAN:
                        rgbColor = C64_RGB_COLOR_CYAN;
                        break;
                    case C64_COLOR_CODE_PURPLE:
                        rgbColor = C64_RGB_COLOR_PURPLE;
                        break;
                    case C64_COLOR_CODE_GREEN:
                        rgbColor = C64_RGB_COLOR_GREEN;
                        break;
                    case C64_COLOR_CODE_BLUE:
                        rgbColor = C64_RGB_COLOR_BLUE;
                        break;
                    case C64_COLOR_CODE_YELLOW:
                        rgbColor = C64_RGB_COLOR_YELLOW;
                        break;
                    case C64_COLOR_CODE_ORANGE:
                        rgbColor = C64_RGB_COLOR_ORANGE;
                        break;
                    case C64_COLOR_CODE_BROWN:
                        rgbColor = C64_RGB_COLOR_BROWN;
                        break;
                    case C64_COLOR_CODE_LIGHTRED:
                        rgbColor = C64_RGB_COLOR_LIGHTRED;
                        break;
                    case C64_COLOR_CODE_DARKGREY:
                        rgbColor = C64_RGB_COLOR_DARKGREY;
                        break;
                    case C64_COLOR_CODE_GREY:
                        rgbColor = C64_RGB_COLOR_GREY;
                        break;
                    case C64_COLOR_CODE_LIGHTGREEN:
                        rgbColor = C64_RGB_COLOR_LIGHTGREEN;
                        break;
                    case C64_COLOR_CODE_LIGHTBLUE:
                        rgbColor = C64_RGB_COLOR_LIGHTBLUE;
                        break;
                    case C64_COLOR_CODE_LIGHTGREY:
                        rgbColor = C64_RGB_COLOR_LIGHTGREY;
                        break;
                }
                return rgbColor;
            }


            var chardata = [];
            var srcdata  = [];
            var petsciiCharacterCodes = new Uint8Array((WIDTH/CWIDTH) * (HEIGHT/CHEIGHT));
            var c64CharacterColors =    new Uint8Array((WIDTH/CWIDTH) * (HEIGHT/CHEIGHT));
            
            var characterContainer;
            var characterCanvas = [];
            
            // format number between 0-255 into a three column string (padding with leading zeros as necessary, i.e. 1 -> 001)
            function FormatNumberStr(colorCode) {
                var colorCodeStr = colorCode.toString();
                while (colorCodeStr.length < 3) {
                    colorCodeStr = "0" + colorCodeStr;
                }
                return colorCodeStr;
            }

			var SaveByteArray = (function () {
                var a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                
                return function (characterCodes, characterColors, inputFileName, outputFileName, compatibleOutputEnabled) {
                    var blob = new Blob([characterCodes], {type: "application/octet-stream"});
                    if (compatibleOutputEnabled) {
                         var backgroundColor_number = document.getElementById('backgroundColor_number');
                         var backgroundColorCode = backgroundColor_number.value;

                        var bufStr = "// generated by petscii_converter.html\n" +
                                     "//    imagefile: " + inputFileName + "\n" +
                                     "//     contrast: " + contrast + "\n" +
                                     "//   brightness: " + brightness + "\n" +
                                     "unsigned char frame0000[]={// 1 byte border color, 1 byte background color, 1000 bytes PETSCII character codes, 1000 bytes character colors\n" +
                                     FormatNumberStr(backgroundColorCode) + "," + FormatNumberStr(backgroundColorCode) + ",\n";
                        for (var i=0;i<characterCodes.length;i++) {
                            bufStr = bufStr + FormatNumberStr(characterCodes[i]) + ",";
                            if ((i+1) % (WIDTH/CWIDTH) == 0) {
                                bufStr = bufStr + "\n";
                            }
                        }
                        for (var i=0; i<characterColors.length; i++) {
                            bufStr = bufStr + FormatNumberStr(characterColors[i]) + ",";
                            if ((i+1) % (WIDTH/CWIDTH) == 0) {
                                bufStr = bufStr + "\n";
                            }
                        }
                        bufStr = bufStr + "};\n";
                        bufStr = bufStr + "// META: 40 25 C64 upper";
                        blob = new Blob([bufStr], {type: "text/plain"});
                    }
                    var url  = window.URL.createObjectURL(blob);
                    
                    a.href = url;
                    a.download = outputFileName;
                    a.click();
                    
                    window.URL.revokeObjectURL(url);
                };
			}());
            
            // read the value of the color switch and update the selected colors array accordingly
            function ManageSelectedColors(switchId, colorRgb) {
                var color_switch = document.getElementById(switchId);
                var color_enabled = color_switch.checked ? true:false;
                var color_index = FindIndexOfSelectedColor(colorRgb);
                if (color_enabled)
                {
                    if (color_index == -1)
                    {
                        C64_SELECTED_RGB_COLORS.push(colorRgb);
                    }
                }
            }

            // Set switch enable status
            function ManageInputEnabled(switchId,enable) {
                var switch_manage = document.getElementById(switchId);
                switch_manage.disabled = enable ? false:true;
            }

            // Set switch checked status
            function ManageSwitchSelected(switchId,select) {
                var switch_manage = document.getElementById(switchId);
                switch_manage.checked = select ? true:false;
            }

            function UpdateOutputFileName()
            {
                var compatibleOutput_switch = document.getElementById('compatibleOutput_switch');
                var compatibleOutputEnabled = compatibleOutput_switch.checked ? true:false;
                var savePetscii_element = document.getElementById('savePetsciiFileName');
                var savePetsciiFileName = savePetscii_element.value;
                if (savePetsciiFileName.length == 0)
                {
                    savePetsciiFileName = document.getElementById('loadImageFileName').value;
                }
                if (savePetsciiFileName.length == 0)
                {
                    savePetsciiFileName = "petsciiart";
                }
                if (compatibleOutputEnabled) {
                    savePetscii_element.value = savePetsciiFileName.split('.')[0] + ".c"
                } else {
                    savePetscii_element.value = savePetsciiFileName.split('.')[0] + ".pet"
                }
            }

            function Init() {
                document.getElementById('loadImageFile_button').onclick = function() {
                    LoadImageFile(document.getElementById('loadImageFileName').value);
                    UpdateOutputFileName();
                };

                document.getElementById('renderWorkingImage_button').onclick = function() {
                    RenderWorkingImage();
                };
                
                function SetupMatchExactColorAlgorithm() {
                    var matchExactColorAlgorithm_switch = document.getElementById('matchExactColorAlgorithm_switch');
                    var matchExactColorAlgorithm = matchExactColorAlgorithm_switch.checked ? true:false;
                    if (matchExactColorAlgorithm)
                    {
                        ManageSwitchSelected('minimizeColorDifferencesAlgorithm_switch', false);

                        ManageInputEnabled('blackAndWhiteDither_switch', false);
                        ManageSwitchSelected('blackAndWhiteDither_switch', true);
                        SetupBlackAndWhiteDithering();

                        ManageInputEnabled('colorBlack_switch', false);
                        ManageSwitchSelected('colorBlack_switch', false);
                        ManageInputEnabled('colorWhite_switch', false);
                        ManageSwitchSelected('colorWhite_switch', true);
                        ManageInputEnabled('colorRed_switch', false);
                        ManageSwitchSelected('colorRed_switch', false);
                        ManageInputEnabled('colorCyan_switch', false);
                        ManageSwitchSelected('colorCyan_switch', false);
                        ManageInputEnabled('colorPurple_switch', false);
                        ManageSwitchSelected('colorPurple_switch', false);
                        ManageInputEnabled('colorGreen_switch', false);
                        ManageSwitchSelected('colorGreen_switch', false);
                        ManageInputEnabled('colorBlue_switch', false);
                        ManageSwitchSelected('colorBlue_switch', false);
                        ManageInputEnabled('colorYellow_switch', false);
                        ManageSwitchSelected('colorYellow_switch', false);
                        ManageInputEnabled('colorOrange_switch', false);
                        ManageSwitchSelected('colorOrange_switch', false);
                        ManageInputEnabled('colorBrown_switch', false);
                        ManageSwitchSelected('colorBrown_switch', false);
                        ManageInputEnabled('colorLightRed_switch', false);
                        ManageSwitchSelected('colorLightRed_switch', false);
                        ManageInputEnabled('colorDarkGrey_switch', false);
                        ManageSwitchSelected('colorDarkGrey_switch', false);
                        ManageInputEnabled('colorGrey_switch', false);
                        ManageSwitchSelected('colorGrey_switch', false);
                        ManageInputEnabled('colorLightGreen_switch', false);
                        ManageSwitchSelected('colorLightGreen_switch', false);
                        ManageInputEnabled('colorLightBlue_switch', false);
                        ManageSwitchSelected('colorLightBlue_switch', false);
                        ManageInputEnabled('colorLightGrey_switch', false);
                        ManageSwitchSelected('colorLightGrey_switch', false);

                        ManageInputEnabled('backgroundColor_number', false);
                        var backgroundColor_number = document.getElementById('backgroundColor_number');
                        backgroundColor_number.value = 0;

                    } else {
                        ManageSwitchSelected('minimizeColorDifferencesAlgorithm_switch', true);

                        ManageInputEnabled('blackAndWhiteDither_switch', true);

                        ManageInputEnabled('colorBlack_switch', true);
                        ManageInputEnabled('colorWhite_switch', true);
                        ManageInputEnabled('colorRed_switch', true);
                        ManageInputEnabled('colorCyan_switch', true);
                        ManageInputEnabled('colorPurple_switch', true);
                        ManageInputEnabled('colorGreen_switch', true);
                        ManageInputEnabled('colorBlue_switch', true);
                        ManageInputEnabled('colorYellow_switch', true);
                        ManageInputEnabled('colorOrange_switch', true);
                        ManageInputEnabled('colorBrown_switch', true);
                        ManageInputEnabled('colorLightRed_switch', true);
                        ManageInputEnabled('colorDarkGrey_switch', true);
                        ManageInputEnabled('colorGrey_switch', true);
                        ManageInputEnabled('colorLightGreen_switch', true);
                        ManageInputEnabled('colorLightBlue_switch', true);
                        ManageInputEnabled('colorLightGrey_switch', true);

                        ManageInputEnabled('backgroundColor_number', true);
                    }
                }

                document.getElementById('matchExactColorAlgorithm_switch').onclick = function() {
                    SetupMatchExactColorAlgorithm();
                    SetupMinimizeColorDifferencesAlgorithm();
                };

                function SetupMinimizeColorDifferencesAlgorithm() {
                    var minimizeColorDifferencesAlgorithm_switch = document.getElementById('minimizeColorDifferencesAlgorithm_switch');
                    var minimizeColorDifferencesAlgorithm = minimizeColorDifferencesAlgorithm_switch.checked ? true:false;
                    if (minimizeColorDifferencesAlgorithm)
                    {
                        ManageSwitchSelected('matchExactColorAlgorithm_switch', false);
                    } else {
                        ManageSwitchSelected('matchExactColorAlgorithm_switch', true);
                    }
                }

                document.getElementById('minimizeColorDifferencesAlgorithm_switch').onclick = function() {
                    SetupMinimizeColorDifferencesAlgorithm();
                    SetupMatchExactColorAlgorithm();
                };

                function SetupBlackAndWhiteDithering()
                {
                    var blackAndWhiteDither_switch = document.getElementById('blackAndWhiteDither_switch');
                    var blackAndWhiteDither_enabled = blackAndWhiteDither_switch.checked ? true:false;
                    if (blackAndWhiteDither_enabled)
                    {
                        // when dithering also perform greyscale conversion
                        ManageInputEnabled('greyscaleConversion_switch', false);
                        ManageSwitchSelected('greyscaleConversion_switch', true);
                    } else {
                        ManageInputEnabled('greyscaleConversion_switch', true);
                    }
                }

                document.getElementById('blackAndWhiteDither_switch').onclick = function() {
                    SetupBlackAndWhiteDithering();
                }

                document.getElementById('renderCharacterSets_button').onclick = function() {
                    C64_SELECTED_RGB_COLORS = [];
                    ManageSelectedColors('colorBlack_switch', C64_RGB_COLOR_BLACK);
                    ManageSelectedColors('colorWhite_switch',  C64_RGB_COLOR_WHITE);
                    ManageSelectedColors('colorRed_switch', C64_RGB_COLOR_RED);
                    ManageSelectedColors('colorCyan_switch', C64_RGB_COLOR_CYAN);
                    ManageSelectedColors('colorPurple_switch', C64_RGB_COLOR_PURPLE);
                    ManageSelectedColors('colorGreen_switch', C64_RGB_COLOR_GREEN);
                    ManageSelectedColors('colorBlue_switch', C64_RGB_COLOR_BLUE);
                    ManageSelectedColors('colorYellow_switch', C64_RGB_COLOR_YELLOW);
                    ManageSelectedColors('colorOrange_switch', C64_RGB_COLOR_ORANGE);
                    ManageSelectedColors('colorBrown_switch', C64_RGB_COLOR_BROWN);
                    ManageSelectedColors('colorLightRed_switch', C64_RGB_COLOR_LIGHTRED);
                    ManageSelectedColors('colorDarkGrey_switch', C64_RGB_COLOR_DARKGREY);
                    ManageSelectedColors('colorGrey_switch', C64_RGB_COLOR_GREY);
                    ManageSelectedColors('colorLightGreen_switch', C64_RGB_COLOR_LIGHTGREEN);
                    ManageSelectedColors('colorLightBlue_switch', C64_RGB_COLOR_LIGHTBLUE);
                    ManageSelectedColors('colorLightGrey_switch', C64_RGB_COLOR_LIGHTGREY);
                    RenderCharacterSets();
                }

                document.getElementById('renderPetscii_button').onclick = function() {
                    RenderPetsciiImage();
                };

                document.getElementById('savePetsciiFile_button').onclick = function() {
                    var compatibleOutput_switch = document.getElementById('compatibleOutput_switch');
                    var compatibleOutputEnabled = compatibleOutput_switch.checked ? true:false;
                    var inputFilePath = document.getElementById('loadImageFileName').value;
                    var inputFileName = inputFilePath.split('\\').pop().split('/').pop();
                    SaveByteArray(petsciiCharacterCodes, c64CharacterColors, inputFileName, document.getElementById('savePetsciiFileName').value, compatibleOutputEnabled);
                };

                document.getElementById('compatibleOutput_switch').onclick = function() {
                    UpdateOutputFileName();
                };
            }

            function LoadImageFile(inputFilePath) {
                var inputFileName = inputFilePath.split('\\').pop().split('/').pop();
                var sourceImage = document.getElementById('sourceImage');
                sourceImage.crossOrigin = "anonymous";
                sourceImage.title = inputFileName;
                sourceImage.src = inputFileName;

                var savePetscii_element = document.getElementById('savePetsciiFileName');
                savePetscii_element.value = inputFileName.split('.')[0] + ".pet"
            }

            function RenderWorkingImage() {
                var sourceImage = document.getElementById('sourceImage');

                var workingImageCanvas = document.getElementById('workingImageCanvas');
                var workingImageCanvasContext = workingImageCanvas.getContext("2d", { willReadFrequently: true });
                workingImageCanvasContext.drawImage(sourceImage,0,0,WIDTH,HEIGHT);

                var blackAndWhiteDither_switch = document.getElementById('blackAndWhiteDither_switch');
                var skipDithering = blackAndWhiteDither_switch.checked ? false:true;
                var greyscaleConversion_switch = document.getElementById('greyscaleConversion_switch');
                var greyscaleConversion = greyscaleConversion_switch.checked ? true:false;
                srcdata = CreateWorkingImage(workingImageCanvasContext, WIDTH, HEIGHT, skipDithering, greyscaleConversion, false, false); //Adjust contrast, Adjust brightness
            }

            function RenderCharacterSets() {
                var backgroundColor_number = document.getElementById('backgroundColor_number');
                var backgroundColorCode = parseInt(backgroundColor_number.value);
                var backgroundColorRgb = GetRgbColor(backgroundColorCode);

                var character = document.getElementById("character");
                characterContainer = document.getElementById("charsetContainer");

                //clean up character elements from last run (if any)
                while (characterContainer.hasChildNodes()) {
                    characterContainer.removeChild(characterContainer.firstChild);
                }

                characterCanvas = [];
                var j = 0;
                for (var selectedColorIndex=0; selectedColorIndex<C64_SELECTED_RGB_COLORS.length; selectedColorIndex++) {
                    for(var i=0;i<CHARACTERS;i++) {
                        var charCanvas = document.createElement("canvas");
                        charCanvas.setAttribute("width", CWIDTH);
                        charCanvas.setAttribute("height",CHEIGHT);
                        
                        charCanvas.style.width       = CWIDTH  + "px";
                        charCanvas.style.height      = CHEIGHT + "px";
                        charCanvas.style.marginRight = "2px";
                        
                        characterContainer.appendChild(charCanvas);
                        characterCanvas.push(charCanvas);
                    }
                    characterContainer.appendChild(document.createElement("br"));
                    
                    character.onload = function() {
                        var charCanvas  = characterCanvas[j];
                        var charContext = charCanvas.getContext("2d", { willReadFrequently: true });
                        var calculatedColorIndex = Math.floor(j/CHARACTERS);
                        
                        charContext.drawImage(character, 0, 0);
                        pxbuf = CreateWorkingImage(charContext, CWIDTH, CHEIGHT, true, true, true, true); //Skip dithering, Perform greyscale conversion, Skip contrast, Skip brightness
                        // change character data color
                        for(var px=0; px<pxbuf.length; px++) {
                            // dithering, for a single color white font this won't change anything. set to desired color
                            if(pxbuf[px][0] < 128) { //because font is single color white and RGB components are equal after greyscale conversion (above) we only need to compare one color component
                                pxbuf[px][0] = backgroundColorRgb[0];
                                pxbuf[px][1] = backgroundColorRgb[1];
                                pxbuf[px][2] = backgroundColorRgb[2];
                            } else {
                                pxbuf[px][0] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][0];
                                pxbuf[px][1] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][1];
                                pxbuf[px][2] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][2];
                            }
                        }
                        chardata[j] = pxbuf;

                        var imageWidth = charContext.canvas.clientWidth;
                        var imageHeight = charContext.canvas.clientHeight;
                        var imageData = charContext.getImageData(0, 0, imageWidth, imageHeight);
                        var imagePixels = imageData.data;
                        // change character image color
                        for(var k=0; k<imagePixels.length; k+=4)
                        {
                            // dithering, for a single color white font this won't change anything. set to desired color
                            if (imagePixels[k  ] < 128)
                            {
                                imagePixels[k  ] = backgroundColorRgb[0];
                                imagePixels[k+1] = backgroundColorRgb[1];
                                imagePixels[k+2] = backgroundColorRgb[2];
                            } else {
                                imagePixels[k  ] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][0];
                                imagePixels[k+1] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][1];
                                imagePixels[k+2] = C64_SELECTED_RGB_COLORS[calculatedColorIndex][2];
                            }
                            imagePixels[k+3] = 255;
                        }
                        charContext.putImageData(imageData, 0, 0);

                        j++;
                        loadCharacter();
                    };

                    var loadCharacter = function() {
                        if(j >= (CHARACTERS*C64_SELECTED_RGB_COLORS.length)) {
                            return;
                        }
                        character.src = CHARSET+"/"+(j%CHARACTERS)+".gif";
                    };
                    
                    loadCharacter();
                }
            }

            function RenderPetsciiImage() {
                var minimizeColorDifferencesAlgorithm_switch = document.getElementById('minimizeColorDifferencesAlgorithm_switch');
                var minimizeColorDifferencesAlgorithm = minimizeColorDifferencesAlgorithm_switch.checked ? true:false;

                var canvas = document.getElementById('canvas');
                var canvasContext = canvas.getContext("2d", { willReadFrequently: true });
                Render(canvasContext,minimizeColorDifferencesAlgorithm);
            }
            
            function WeightAlphaChannel(color, alpha) {
                //Weight the alpha channel. --Thanks to Chris Roy!
                var aDiff = 256 - alpha;
                var gDiff = 256 - color;
                var newColor = (gDiff * aDiff / 256) + color;
                return newColor;
            }

            function CreateWorkingImage(context,w,h,skipDithering,greyscaleConversion, skipContrast, skipBrightness) {
                var imgd = context.getImageData(0, 0, w,h);

                if (!skipContrast) {
                    var imageContrast_number = document.getElementById('imageContrast_number');
                    contrast = parseInt(imageContrast_number.value);
                    if (contrast != 0) {
                        imgd = ContrastImage(imgd, contrast);
                    } 
                }

                if (!skipBrightness) {
                    var imageBrightness_number = document.getElementById('imageBrightness_number');
                    brightness = parseInt(imageBrightness_number.value);
                    if (brightness != 0) {
                        imgd = BrightnessImage(imgd, brightness);
                    }
                }

                var pix  = imgd.data;
                
                var x = 0;
                var y = 0;
                
                var id = context.createImageData(1,1);
                var d  = id.data;
                
                var ebBuf = [];
                
                for(var i=0,il=pix.length;i<il;i+=4) {
                    var newRed;
                    var newGreen;
                    var newBlue;

                    if (greyscaleConversion)
                    {
                        newRed   = pix[i  ] * .3 + 
                                   pix[i+1] * .59 + 
                                   pix[i+2] * .11;
                        newGreen = newRed;
                        newBlue  = newRed;
                    } else {
                        newRed   = pix[i  ]; 
                        newGreen = pix[i+1];
                        newBlue  = pix[i+2];
                    }
                    newColor = [newRed, newGreen, newBlue];
                    ebBuf.push(newColor);
                }
                
                if (!skipDithering) {
                    Dither(ebBuf,w,h);
                }
                
                for(var i=0;i<ebBuf.length;i++) {
                    d[0] = ebBuf[i][0];
                    d[1] = ebBuf[i][1];
                    d[2] = ebBuf[i][2];
                    d[3] = 255;
                    context.putImageData(id,x,y);                

                    x++;
                    if(x >= WIDTH) {
                        x = 0;
                        y++;
                    }
                }
                
                return ebBuf;
            }

            // refer to: https://stackoverflow.com/questions/10521978/html5-canvas-image-contrast
            function ContrastImage(imageData, contrast) {  //input range [-100..100]
                var data = imageData.data;
                contrast = (contrast/100) + 1; //convert to decimal and shift range: [0..2]
                var intercept = 259 * (1 - contrast);
                for(var i=0; i<data.length; i+=4) {   //r,g,b,a
                    data[i  ] = Math.trunc(data[i  ] * contrast + intercept);
                    data[i+1] = Math.trunc(data[i+1] * contrast + intercept);
                    data[i+2] = Math.trunc(data[i+2] * contrast + intercept);
                }
                return imageData;
            }

            // refer to: https://hackernoon.com/image-processing-algorithms-adjusting-contrast-and-image-brightness-0y4y318a
            function BrightnessImage(imageData, brightness) {  //input range [-100..400]
                var data = imageData.data;
                brightness = brightness / 100; //shift range: [-1..4]
                for(var i=0; i<data.length; i+=4) {   //r,g,b,a
                    data[i  ] = Math.trunc(data[i  ] * (1 + brightness));
                    data[i+1] = Math.trunc(data[i+1] * (1 + brightness));
                    data[i+2] = Math.trunc(data[i+2] * (1 + brightness));
                }
                return imageData;
            };

            //dithering from greyscale to a two-color image (black/white)
            function Dither(sb, w, h) {   // source buffer, width, height
                for(var y=0; y<h; y++) {
                    for(var x=0; x<w; x++) {
                        var ci = y*w+x;               // current buffer index
                        var cc = sb[ci][0];           // current color (red, red component is same as green and blue since its a greyscale image)
                        var rc = (cc<128?0:255);      // real (rounded) color
                        var err = cc-rc;              // error amount

                        sb[ci][0] = rc;                  // saving real color (red)
                        sb[ci][1] = rc;                  // saving real color (green, since image is greyscale color is the same as red)
                        sb[ci][2] = rc;                  // saving real color (blue, since image is greyscale color is the same as red)

                        if(x+1 < w) {
                            sb[ci+1][0] += (err*7)>>4;  // if right neighbour exists (red)
                            sb[ci+1][1] += (err*7)>>4;  // if right neighbour exists (green)
                            sb[ci+1][2] += (err*7)>>4;  // if right neighbour exists (blue)
                        }
    
                        // if there is another line below our current image line then use it for rounding error
                        if(y+1 < h) {
                            if(x > 0) {
                                sb[ci+w-1][0] += (err*3)>>4;  // bottom left neighbour (red)
                                sb[ci+w-1][1] += (err*3)>>4;  // bottom left neighbour (green)
                                sb[ci+w-1][2] += (err*3)>>4;  // bottom left neighbour (blue)
                            }

                            sb[ci+w][0] += (err*5)>>4;  // bottom neighbour (red)
                            sb[ci+w][1] += (err*5)>>4;  // bottom neighbour (green)
                            sb[ci+w][2] += (err*5)>>4;  // bottom neighbour (blue)

                            if(x+1 < w) {
                                sb[ci+w+1][0] += (err*1)>>4;  // bottom right neighbour (red)
                                sb[ci+w+1][1] += (err*1)>>4;  // bottom right neighbour (green)
                                sb[ci+w+1][2] += (err*1)>>4;  // bottom right neighbour (blue)
                            }
                        }
                    }
                }
            }
            
            function Render(canvasContext,minimizeColorDifferencesAlgorithm) {
                var charsWide = WIDTH  / CWIDTH;
                var charsHigh = HEIGHT / CHEIGHT;
                
                var charCount = charsWide * charsHigh;
                
                var c = 0;
                for(var y=0;y<charsHigh;y++) {
                    for(var x=0;x<charsWide;x++) {
                        var charBuf  = GetSourceChar(c);
                        var matchValues = FindMatch(charBuf,minimizeColorDifferencesAlgorithm);
                        c64CharacterColors[c] = GetC64ColorCode(C64_SELECTED_RGB_COLORS[matchValues.selectedColorIndex]);
                        var characterSetOffset = matchValues.selectedColorIndex * 256;
                        canvasContext.drawImage(characterCanvas[matchValues.characterOffset], x*CWIDTH, y*CHEIGHT);
                        petsciiCharacterCodes[c] = matchValues.characterOffset - characterSetOffset;
                        c++;
                    }
                }
            }
            
            function GetSourceChar(c) {
                var charsWide = (WIDTH  / CWIDTH); // 320 / 8 = 40
                
                var bytesPerRastRow = CWIDTH  * charsWide; // 8 * 40 = 320
                var bytesPerCharRow = CHEIGHT * bytesPerRastRow; // 8 * 320 = 2560
                
                var startByte = 0;
                while(c > charsWide) {
                    startByte += bytesPerCharRow;
                    c -= charsWide;
                }
                
                while(c) {
                    startByte += CWIDTH;
                    c--;
                }
                
                var charBuf = [];
                for(var y=0;y<CHEIGHT;y++) {
                    for(var x=0;x<CWIDTH;x++) {
                        charBuf.push(srcdata[startByte+x]);
                    }
                    startByte += bytesPerRastRow;
                }
                
                return charBuf;
            }
            
            function FindMatch(buf, minimizeColorDifferencesAlgorithm) {
                var maximumDifference = (CWIDTH * CHEIGHT);
                if (minimizeColorDifferencesAlgorithm) {
                    maximumDifference *= 3*255;
                }
                maximumDifference++;
                var smallestDifference = maximumDifference;
                var bestMatch = {characterOffset: 0, selectedColorIndex: 0};
                
                // check the current character against all available colors for the best match.
                for(var i=0; i<CHARACTERS*C64_SELECTED_RGB_COLORS.length; i++) {
                    var currentDifference = Diff(buf, chardata[i], minimizeColorDifferencesAlgorithm, i == 0 ? true:false);
                    if(currentDifference < smallestDifference) {
                        bestMatch.characterOffset = i;
                        bestMatch.selectedColorIndex = Math.floor(i/CHARACTERS);
                        smallestDifference = currentDifference;
                        if(currentDifference == 0) {
                            break; //Perfect Match.
                        }
                    }
                }
                
                return bestMatch;
            }
            
            function Diff(bufa, bufb, minimizeColorDifferencesAlgorithm,debug) {
                var difference = 0;
                for(var i=0; i<bufa.length; i++) {
                    if (minimizeColorDifferencesAlgorithm) {
                        difference += Math.abs(bufa[i][0] - bufb[i][0]) + Math.abs(bufa[i][1] - bufb[i][1]) + Math.abs(bufa[i][2] - bufb[i][2]);
                    } else { //matchExactColorAlgorithm
                        if ( (bufa[i][0] != bufb[i][0]) || (bufa[i][1] != bufb[i][1]) || (bufa[i][2] != bufb[i][2]) ) {
                            difference++;
                        }
                    }
                }
                return difference;
            }
        </script>

        <h2><center>C64 PETSCII Art Generator v4</center></h2>
        <center>Originally written by Gregory Nacu, <a href="https://c64os.com">C64OS.com</a></center></b>
        <center>Enhancements by Warren Wilbur</center>

        <h3>1. Select any image file in the same directory as petscii_converter.html</h3>

        <i>Loading source images and character set images requires support for cross origin file loading. To do this start chrome on the command line with the --allow-file-access-from-files option. e.g. "D:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --allow-file-access-from-files file:///D:/petsciirender/petscii_converter.html</i><br><br>
        <input type="file" value='Sample Images/s_classic.png' id="loadImageFileName" />
        <input type='button' value='Load Image File' id='loadImageFile_button'>
        <br>

        <h3>Original Image</h3>
        <img src='Sample Images/s_classic.png' id='sourceImage' style='width:320px;height:200px;'>

        <h3>2. Make image adjustments and click to create working image</h3>

        <h5>2.1. Select algorithm for rendering the PETSCII image</h5>
        <input type="checkbox" id="matchExactColorAlgorithm_switch" class="checkbox" />
        <label for="matchExactColorAlgorithm_switch">Use 'match exact color' algorithm</label>&nbsp;&nbsp;&nbsp;

        <input type="checkbox" id="minimizeColorDifferencesAlgorithm_switch" checked class="checkbox" />
        <label for="minimizeColorDifferencesAlgorithm_switch">Use 'minimize absolute color differences' algorithm</label><br>

        <h5>2.2. Select working image adjustments to enhance output</h5>
        <input type="checkbox" id="blackAndWhiteDither_switch" class="checkbox" />
        <label for="blackAndWhiteDither_switch">Dither to a two-color image (black/white)</label>&nbsp;&nbsp;&nbsp;

        <input type="checkbox" id="greyscaleConversion_switch" class="checkbox" />
        <label for="greyscaleConversion_switch">Convert to greyscale image</label>&nbsp;&nbsp;&nbsp;<br>

        <input type="number" id="imageContrast_number" name="imageContrast_number" value="0" min="-100" max="100" value="0" />
        <label id="imageContrast_label" for="imageContrast_number">Image Contrast (-100..100 percent)</label>&nbsp;&nbsp;&nbsp;&nbsp;

        <input type="number" id="imageBrightness_number" name="imageBrightness_number" value="0" min="-100" max="400" value="0" />
        <label id="imageBrightness_label" for="imageBrightness_number">Image Brightness (-100..400 percent)</label>
        <br><br>

        <input type='button' value='Render Working Image' id='renderWorkingImage_button'>

        <h3>Working Image</h3>
        <canvas width=320 height=200 style='width:320px;height:200px;' id='workingImageCanvas'></canvas>

        <h3>3. Choose colors and click to render Character Sets</h3>

        <h5>3.1. Choose character set foreground colors</h3>
        <input type="checkbox" id="colorBlack_switch" checked class="checkbox" />
        <label for="colorBlack_switch">Black(0)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorWhite_switch" checked class="checkbox" />
        <label for="colorWhite_switch">White(1)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorRed_switch" checked class="checkbox" />
        <label for="colorRed_switch">Red(2)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorCyan_switch" checked class="checkbox" />
        <label for="colorCyan_switch">Cyan(3)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorPurple_switch" checked class="checkbox" />
        <label for="colorPurple_switch">Purple(4)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorGreen_switch" checked class="checkbox" />
        <label for="colorGreen_switch">Green(5)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorBlue_switch" checked class="checkbox" />
        <label for="colorBlue_switch">Blue(6)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorYellow_switch" checked class="checkbox" />
        <label for="colorYellow_switch">Yellow(7)</label>&nbsp;&nbsp;&nbsp;<br>
        <input type="checkbox" id="colorOrange_switch" checked class="checkbox" />
        <label for="colorOrange_switch">Orange(8)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorBrown_switch" checked class="checkbox" />
        <label for="colorBrown_switch">Brown(9)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorLightRed_switch" checked class="checkbox" />
        <label for="colorLightRed_switch">Light Red(10)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorDarkGrey_switch" checked class="checkbox" />
        <label for="colorDarkGrey_switch">Dark Grey(11)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorGrey_switch" checked class="checkbox" />
        <label for="colorGrey_switch">Grey(12)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorLightGreen_switch" checked class="checkbox" />
        <label for="colorLightGreen_switch">Light Green(13)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorLightBlue_switch" checked class="checkbox" />
        <label for="colorLightBlue_switch">Light Blue(14)</label>&nbsp;&nbsp;&nbsp;
        <input type="checkbox" id="colorLightGrey_switch" checked class="checkbox" />
        <label for="colorLightGrey_switch">Light Grey(15)</label>&nbsp;&nbsp;&nbsp;

        <h5>3.2. Choose character set background color</h3>
        <label for="backgroundColor_number">Background color (between 0 and 15):</label>&nbsp;&nbsp;&nbsp;
        <input type="number" id="backgroundColor_number" value="0" name="backgroundColor_number" min="0" max="15">
        <br><br>

        <input type='button' value='Render Character Sets' id='renderCharacterSets_button'>

        <h3>Character Sets</h3>
        <div id='charsetContainer'></div>
        <img src='' id='character' style='display:none;'>

        <h3>4. After generating Character Sets, click to render PETSCII image</h3>
        <input type='button' value='Render PETSCII' id='renderPetscii_button'>

        <h3>Canvas Image</h3>
        <canvas width=320 height=200 style='width:320px;height:200px;' id='canvas'></canvas>

        <h3>5. After rendering Canvas image, enter filename and click to save PETSCII mosaic to file</h3>
        <input type="checkbox" id="compatibleOutput_switch" class="checkbox" />
        <label for="compatibleOutput_switch">Enable PETSCII Compositor compatible .C output file</label><br><br>
        <input type='text' value='petsciiart.pet' id='savePetsciiFileName'>
        <input type='button' value='Save PETSCII File' id='savePetsciiFile_button'>
    </body>
</html>
